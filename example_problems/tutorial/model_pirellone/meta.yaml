%YAML 1.2
---
public_folder: public
services:
  gimme_instance:
    description: 'This service provides you with instances for the Pirellone problem, i.e., a 0/1-matrices with the given number of rows (argument m) and columns (argument n). You have two main options when calling this service:\n    [instance_spec=catalogue_name] to get the instance with a specific id out from the named catalogue of hardcoded instances.\n    [instance_spec=random] to get the pseudo-random instance for a given seed. As seed, you can use any integer from 100000 to 999999 or let the service choose the seed at random (seed=random_seed). In the second case you are given the possibility to specify whether you are interested into a solvabe instance or into an instance admitting no solution, or let the service decide also on this. When you want to recall a 0/1-matrix you have already met with this or other services, you only need to recall its seed and the other details in its instance descriptor. By the \''instance descriptor\'' of a pseudo-random Pirellone instance we mean the triple <m,n,seed>.\n   The 0/1-matrix comprising the instance is returned by the service in the form of a stream. You may ask for this stream to get downloaded in a file on your local machine and/or displayed on the screen. Our format for streams storing 0/1-matrices is the following: the first line contains the two integers m and n; then follow m lines, one for each row. The i-th of these lines displays the n binary digits of the i-th row of the matrix, the j-th bit being the element in the j-th column. It is assumed that the row and column indexes start from 1.'
    evaluator: [python,services/gimme_instance_server.py]
    args:
      instance_spec:
        regex: ^(random|catalogue1)$
        default: random
        explain: 'choose an option among:' 
        explain1: '[random] the service uses the seed specificated to generate and return the pseudo-random instance <m,n,seed>.'
        explain2: '[catalogue1] the service will return an instance taken from a catalogue of hardcoded instances (the catalogue named \''catalogue1\''). More precisely, the instance returned is the one with the given instance_id.'
      m:
        regex: ^([1-9][0-9]{0,1})$
        default: 4
        explain: Number of rows of the 0,1-matrix which reports which lights are on or off within the mxn Pirellone skyscraper.
      n:
        regex: ^([1-9][0-9]{0,1})$
        default: 4
        explain: Number of columns of the 0,1-matrix which reports which lights are on or off within the mxn Pirellone skyscraper.
      seed:
        explain: 'Set up this argument when you hold the seed and the instance descriptor of the specific instance that you want to be produced by the service (whether downloaded in local as a file or displayed on your terminal screen). By an \''instance descriptor\'' we mean a triple <m,n,seed> that you may have got from previous calls to this or other services for this problem. When this argument is left to its default value (random_seed) then the service first chooses a seed at random (and communicates it to the user) and then produces the pseudo-random instance <m,n,seed>.'
        regex: ^(random_seed|[1-9][0-9]{5,5})$
        default: random_seed
      instance_id:
        regex: ^([1-9][0-9]*)$
        default: 1
        explain: 'This argument is taken into account when the name of a catalogue of hardcoded instances is passed as argument instance_spec. It is used to identify a particular instance within the named catalogue of hardcoded instances. If you hold the whole problem in local (all sources) then this catalogue of hardcoded instances is automatically set up with make when setting up the server.'
      instance_solvability:
        regex: ^(solvable|unsolvable|surprise_me)$
        default: surprise_me
      format:
        regex: ^(only_matrix.txt|with_m_and_n.txt|dat)$
        default: only_matrix.txt
        explain: choose the encoding for the txt input file.
      silent:
        regex: ^(0|1)$
        default: 0
        explain: If this flag is set to 1 then only the bare instance will be printed. In this way, if you redirect the output to file ('>') you will get a valid instance file for the other services.
      # display:
      #   regex: ^(0|1)$
      #   default: 1
      #   explain: If this flag is set to 1 then the instance file is listed by the service.
      # download:
      #   regex: ^(0|1)$
      #   default: 0
      #   explain: 'If this flag is set to 1 then the instance file is downloaded in the \''download\'' sub-folder of the folder from which this TALight service call has been issued.'
      lang:
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it
  
  compact_sol:
    description: 'You are given a 0,1-matrix P and a sequence s of switch row/column operations that, when subsequently applied to P, lead to the all-0 matrix. Can you produce a shorter sequence with the same property? The 0,1-matrix P is an instance of the Pirellone problem and the sequence s is a solution for that instance. When calling this service you can ask it to freely choose the instance P among the solvable matrices with <m> rows and <n> columns or specify also the random seed such that the instance <m,n,seed> is solvable. Either way, the service will provide you both the instance descriptor (<m,n,seed>), a display of the corresponding matrix P, and a solution s for P that is not shortest possible.'
    evaluator: [python,services/compact_sol_server.py]
    args:
      instance_spec:
        regex: ^(random|seed|terminal)$
        # NOTE: tolto TA_send_files_bot in quanto impedisce poi di ricevere input da terminale, funzione necessaria al fine di sottomettere la propria soluzione più corta.
        # regex: ^(random|seed|terminal|TA_send_files_bot)$
        default: random
        explain: 'choose the way to input your pirellone among:' 
        explain1: '[random] the service generates at random a seed such that the pseudo-random instance <m,n,seed> is solvable. Both the seed and the corresponding matrix P are displayed for your convenience.'
        explain2: '[seed] with this option, the seed for the generation of the solvable <m,n,seed> pseudo-random instance is then provided by you through the `seed` argument of this service. This option allows you to provide an answer for an already encountered instance.'
        explain3: '[terminal] you enter your instance (pirellone) directly by typing it line after line (you can cut-and-paste multiple lines and possibly the whole matrix in one shot).'
        # explain4: '[TA_send_files_bot] with this, you can send to the service an instance (pirellone) encoded in a file sitting in your machine. To send the file you must use the TA_send_files_bot.py bot placed in the model_pirellone/bots/ directory. Call the service with: rtal connect model_pirellone compact_sol -ainstance_spec=TA_send_files_bot -- path_to_bot_dir/TA_send_files_bot.py path_to_instance_file_dir/your_pirellone.txt.'
      m:
        regex: ^([1-9][0-9]{0,1})$
        default: 4
        explain: Number of rows of the pirellone.
      n:
        regex: ^([1-9][0-9]{0,1})$
        default: 4
        explain: Number of columns of the pirellone.
      seed:
        explain: specify the numeric code (any integer in the interval [100000,999999]) to work with an already met pseudo-random instance. When this argument is left to its default value (random_seed) then the service chooses a seed at random, communicates it to the user, and works on the unique pseudo-random instance <m,n,seed>.
        regex: ^(random_seed|[1-9][0-9]{5,5})$
        default: random_seed
      goal:
        regex: ^(m_plus_n|m_plus_n_half|min)$
        default: m_plus_n
        explain: 'Set an upper-bound on the length of your solution. The choiches are as follows:'
        explain1: '[m_plus_n]  yield a solution with at most m+n moves.'
        explain2: '[m_plus_n_half]  yield a solution with at most (m+n)/2 moves.'
        explain3: '[min]  yield a solution with the minimum possible number of moves.'
      lang:
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it
  
  gimme_sol:
    description: 'This service provides you with a solution for an instance (either provided by you or generated at random) for the Pirellone problem. You can even call this service on an already encountered instance (also met with other services): a random instance can be reconstructed from m, n, and its random seed.'
    evaluator: [python, services/gimme_sol_server.py]
    args:
      instance_spec:
        regex: ^(random|seed|terminal)$
        # NOTE: tolto TA_send_files_bot in quanto impedisce poi di ricevere input da terminale, funzione necessaria al fine di sottomettere la propria soluzione più corta.
        # regex: ^(random|seed|terminal|TA_send_files_bot)$
        default: random
        explain: 'choose the way to input your pirellone among:' 
        explain1: '[random] the service generate a seed at random and then returns it as well as the pseudo-random instance <m,n,seed>.'
        explain2: '[seed] the service uses the seed specificated to generate and return the pseudo-random instance <m,n,seed>.'
        explain3: '[terminal] you enter your instance (pirellone) directly by either typing it line after line or through cut and paste operations.'
        # explain4: '[TA_send_files_bot] with this, you can send to the service an instance (pirellone) encoded in a file sitting in your machine. To send the file you must use the TA_send_files_bot.py bot placed in the model_pirellone/bots/ directory. Call the service with: rtal connect model_pirellone compact_sol -ainstance_spec=TA_send_files_bot -- path_to_bot_dir/TA_send_files_bot.py path_to_instance_file_dir/your_pirellone.txt.'
      m:
        regex: ^([1-9][0-9]{0,1})$
        default: 4
        explain: Number of rows of the pirellone.
      n:
        regex: ^([1-9][0-9]{0,1})$
        default: 4
        explain: Number of columns of the pirellone.
      seed:
        explain: specify the numeric code (any integer in the interval [100000,999999]) to work with an already met pseudo-random instance. When this argument is left to its default value (random_seed) then the service chooses a seed at random, communicates it to the user, and works on the unique pseudo-random instance <m,n,seed>.
        regex: ^(random_seed|[1-9][0-9]{5,5})$
        default: random_seed
      sol_style:
        regex: ^(seq|subset)$
        default: seq
        explain: 'choose how to encode the solution[seq]. Either as a list of commands, or as a subset of the row and column switches (i.e., as two incidence 0/1-vectors of length m and n, respectively.'
        example: '[seq] r2 c4 r3 r1, [subset]: 1 0 1\n0 1 1 if the matrix is 3x3'
      lang:
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it
  
  check_sol:
    description: 'This service checks your solution for an instance (either provided by you or generated at random) for the Pirellone problem. You can even call this service on an already encountered random instance (also met with other services): a random instance can be reconstructed from m, n, and its random seed.'
    evaluator: [python, services/check_sol_server.py]
    args:
      instance_spec:
        regex: ^(random|seed|terminal)$
        # NOTE: tolto TA_send_files_bot in quanto impedisce poi di ricevere input da terminale, funzione necessaria al fine di sottomettere la propria soluzione più corta.
        # regex: ^(random|seed|terminal|TA_send_files_bot)$
        default: random
        explain: 'choose the way to input your pirellone among:' 
        explain1: '[random] the service generate a seed at random and then returns it as well as the pseudo-random instance <m,n,seed>.'
        explain2: '[seed] the service uses the seed specificated to generate and return the pseudo-random instance <m,n,seed>.'
        explain3: '[terminal] you enter your instance (pirellone) directly by either typing it line after line or through cut and paste operations.'
        # explain4: '[TA_send_files_bot] with this, you can send to the service an instance (pirellone) encoded in a file sitting in your machine. To send the file you must use the TA_send_files_bot.py bot placed in the model_pirellone/bots/ directory. Call the service with: rtal connect model_pirellone compact_sol -ainstance_spec=TA_send_files_bot -- path_to_bot_dir/TA_send_files_bot.py path_to_instance_file_dir/your_pirellone.txt.'
      m:
        regex: ^([1-9][0-9]{0,1})$
        default: 4
        explain: Number of rows of the pirellone.
      n:
        regex: ^([1-9][0-9]{0,1})$
        default: 4
        explain: Number of columns of the pirellone.
      seed:
        explain: specify the numeric code (any integer in the interval [100000,999999]) to work with an already met pseudo-random instance. When this argument is left to its default value (random_seed) then the service chooses a seed at random, communicates it to the user, and works on the unique pseudo-random instance <m,n,seed>.
        regex: ^(random_seed|[1-9][0-9]{5,5})$
        default: random_seed
      sol_style:
        regex: ^(seq|subset)$
        default: seq
        explain: 'choose how to encode the solution[seq]. Either as a list of commands, or as a subset of the row and column switches (i.e., as two incidence 0/1-vectors of length m and n, respectively.'
        example: '[seq] r2 c4 r3 r1, [subset]: 1 0 1\n0 1 1 if the matrix is 3x3'
      lang:
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it
  
  try_GMPL_model:
    description: 'This service allows you to validate your models for the Pirellone problem. Even if you do not have `glpsol` installed on your machine, still with this service you can send to our server the .mod file containing your GMPL model and a .dat file containing an instance of the problem. The service runs a `gplsol` engine on your model and instance to find out a solution following the instructions contained in your .mod file. To send your files you must use the TA_send_files_bot.py bot placed in the model_asteroid/bots/ directory. Call the service with:\n    rtal connect model_asteroid try_GMPL_model -- path_to_bot_dir/TA_send_files_bot.py mod=path_to_model_file_dir/your_asteroid.mod dat=path_to_instance_file_dir/your_asteroid.dat input=path_to_input_file/input.txt\nHere, the `input.txt` file is required only if you want to get a validation of the solution contained in the file `solution.txt` generated by your model on the server. Examples for the format for the `input.txt` file can be found in the `examples` directory (see in the archive downloaded with `rtal get model_asteroid`).'
    evaluator: [python, services/try_GMPL_model_server.py]
    args:
      display_output:
        regex: ^(0|1)$
        default: 0
        explain: If this flag is set to 1 then the service displays the output of the `gplsol` engine when running your model and instance.
      display_error:
        regex: ^(0|1)$
        default: 0
        explain: If this flag is set to 1 then the service displays the log of the `gplsol` engine when running your model and instance.
      display_solution:
        regex: ^(0|1)$
        default: 0
        explain: If this flag is set to 1 then the service displays the content of the solution.txt file created by your model. This display is a raw listing of the file as it is (might help your debugging from remote).
      check_solution:
        regex: ^(0|1)$
        default: 0
        explain: If this flag is set to 1 then, the solution obtained from GPLSOL will be checked. In order to perform this check, it is mandatory that also the input.txt file is sent to the sever via the TA_send_files_bot.py
      txt_style:
        regex: ^(only_matrix|with_m_and_n)$
        default: only_matrix
        explain: 'choose how to encode the txt input file.'
      sol_style:
        regex: ^(seq|subset)$
        default: subset
        explain: 'choose how to encode the solution[seq]. Either as a list of commands, or as a subset of the row and column switches (i.e., as two incidence 0/1-vectors of length m and n, respectively.'
        example: '[seq] r2 c4 r3 r1, [subset]: 1 0 1\n0 1 1 if the matrix is 3x3'
      instance_id:
        regex: ^(-1|[1-9][0-9]*)$
        default: -1
        explain: 'If different from -1 then the dat file and the input.txt files are those for the instance with id <instance_id> contained in a small archive of reference instances'
      lang: 
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it
  
  try_explicit_formulation:
    description: 'This service takes in input an explicit LP or ILP instance (i.e., a system of linear constraints on a set of real or possibly integer variables (plus, possibly, an objective function) and applies a solver to it in order to obtain a solution. The service returns the outcome of the computation performed by the solver. Call the service with:\n    rtal connect model_lcs try_explicit_formulation -- path_to_bot_dir/TA_send_files_bot.py ef=path_to_your_formulation_file_dir/your_formulation_file\nHere, your formulation file should be valid for the choosen format. See the argument `format` for the currently supported formats.'
    evaluator: [python, services/try_explicit_formulation_server.py]
    args:
      display_output:
        regex: ^(0|1)$
        default: 0
        explain: If this flag is set to 1 then the service displays the output of the `glpsol` engine when running your model and instance.
      display_error:
        regex: ^(0|1)$
        default: 0
        explain: If this flag is set to 1 then the service displays the log of the `glpsol` engine when running your model and instance.
      format:
        regex: ^(mps|freemps|lp|glp|math)$
        default: glp
      lang: 
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it

  eval_GMPL_model:
    description: 'use this service to evaluate a GMPL model of yours. It is assumed that this model is compliant with the .dat file format specifyied by the parameter `dat_style`. Examples of the supported dat styles are given in the folder `examples` where each example instance is encoded in every supported dat style (filename and extensions in the form `instance_name`.`dat_style`.dat) as well as in other formats. These instances comprise the set of public examples. For each tested instance, the service displays its instance_id so that if your model fails you have this handle on an invalidating instance (the service stops at the first failure). You can then use the service `gimme_instance` to download this instance in local and/or the service `try_GMPL_model` (even directly) to get more detailed feedback. Call the service with:\n    rtal connect model_pirellone eval_GMPL_model -- path_to_bot_dir/TA_send_files_bot.py path_to_model_file_dir/your_pirellone.mod'
    evaluator: [python, services/eval_GMPL_model_server.py]
    args:
      goal:
        regex: ^(public_examples|m_and_n_at_most_5|m_and_n_at_most10|m_and_n_at_most20|m_and_n_at_most30|m_and_n_at_most50|m_and_n_at_most100|m_and_n_at_most200|m_and_n_at_most300)$
        default: m_and_n_at_most_5
        explain: To solve bigger instances you might need smarter models, either using some tricks or, even more powerful, a better understanding of the structural properties of the problem.
      type_of_check:
        regex: ^(no|yes|min)$
        default: no
        explain: 'choose among the following options:' 
        explain1: '[no] the `solution.txt` file written by your model is considered ok if it begins with the string \''NO SOLUTION\'' if and only if the testcase pirellone instance has no solution.'
        explain2: '[yes] beyond the above requirement, for all solvable instances, the `solution.txt` file should contain a valid solution which will be checked by the service.'
        explain3: '[min] beyond the above requirement, for all solvable instances, the `solution.txt` should contain the minimum solution.'
      only_solvable_instances:
        regex: ^(0|1)$
        default: 0
        explain: If this flag is set to 1, then your model will be tested only on instances that are guaranteed to possess a solution.
      dat_style:
        regex: ^(default)$
        default: default
        explain: 'choose how to encode the dat file. For now there is only one format'
      sol_style:
        regex: ^(seq|subset)$
        default: subset
        explain: 'choose how to encode the solution[seq]. Either as a list of commands, or as a subset of the row and column switches (i.e., as two incidence 0/1-vectors of length m and n, respectively.'
        example: '[seq] r2 c4 r3 r1, [subset]: 1 0 1\n0 1 1 if the matrix is 3x3'
      lang:
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it
  
  # TODO
  eval_SAT_model:
    evaluator: [python, services/eval_SAT_model_server.py]
    args:
      goal:
        regex: ^(correct|efficient)$
        default: correct
        explain: Set your goal (efficient includes also correct).
      with_check_of_sol:
        regex: ^(0|1)$
        default: 0
        explain: If this flag is set to 1 then, for the yes instances, you should also provide a solution which will be checked by the service.
      seed:
        explain: specify the numeric code (any integer in the interval [100000,999999]) to work with an already met pseudo-random instance. When this argument is left to its default value (random_seed) then the service chooses a seed at random, communicates it to the user, and works on the unique pseudo-random instance <m,n,seed>.
        regex: ^(random_seed|[1-9][0-9]{5,5})$
        default: random_seed
      lang:
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it

  # TODO
  eval_MiniZinc_model:
    evaluator: [python, services/eval_MiniZinc_model_server.py]
    args:
      goal:
        regex: ^(correct|efficient)$
        default: correct
        explain: Set your goal (efficient includes also correct).
      with_check_of_sol:
        regex: ^(0|1)$
        default: 0
        explain: If this flag is set to 1 then, for the yes instances, you should also provide a solution which will be checked by the service.
      seed:
        explain: specify the numeric code (any integer in the interval [100000,999999]) to work with an already met pseudo-random instance. When this argument is left to its default value (random_seed) then the service chooses a seed at random, communicates it to the user, and works on the unique pseudo-random instance <m,n,seed>.
        regex: ^(random_seed|[1-9][0-9]{5,5})$
        default: random_seed
      lang:
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it
  
  # TODO
  eval_your_solver_bot:
    description: 'This service checks your solution for an instance (either provided by you or generated at random). You can even call this service on an already encountered solvable random instance (also met with other services): a solvable random instance can be reconstructed from m, n, and its random seed.'
    evaluator: [python, services/eval_decision_server.py]
    args:
      goal:
        regex: ^(correct|efficient)$
        default: correct
        explain: Set your goal (efficient includes also correct).
      with_check_of_sol:
        regex: ^(0|1)$
        default: 0
        explain: If this flag is set to 1 then, for the yes instances, you should also provide a solution which will be checked by the service.
      seed:
        explain: specify the numeric code to reproduce the very same set of instances as in a previous run. Called with seed=random_seed, the service chooses its seed at random (and communicates it to the user).
        regex: ^(random_seed|[1-9][0-9]{5,5})$
        default: random_seed
      lang:
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it

  synopsis:
    evaluator: [python, services/synopsis/synopsis_server.py]
    args:
      service:
        regex: ^((\S)+)$
        default: synopsis
        explain: any string without space characters but meant to specify one of the services of the problem {problem}
      lang:
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it
      metafile:
        regex: ^(main|en|it)$
        default: main
...

