#!/usr/bin/env python3
"""This file contains the useful functions to handle modelling problem."""
import subprocess, os

from bot_interface import service_server_requires_and_gets_file_of_handle


# CONSTANTS:
TMP_DIRECTORY = '../tmp97815'
MOD_FILENAME  = 'model.mod'
DAT_FILENAME  = 'instance.dat'
SOL_FILENAME  = 'solution.txt'
OUT_FILENAME  = 'output.txt'


def get_path_of(filename):
    """Returns the fullpath among:
        - tmp_directory  #where create this tmp file
        - mod_file       #gmpl model file
        - dat_file       #gmpl data file
        - output_file    #output of GPLSOL
        - solution_file  #solution generated by GPLSOL
        solution_file"""
    current_dir = os.path.abspath(os.path.dirname(__file__))
    TMP_DIR_PATH = os.path.join(current_dir, TMP_DIRECTORY)
    if filename == 'tmp_directory':
        return TMP_DIR_PATH
    elif filename == 'mod_file':
        return os.path.join(TMP_DIR_PATH, MOD_FILENAME)
    elif filename == 'dat_file':
        return os.path.join(TMP_DIR_PATH, DAT_FILENAME)
    elif filename == 'output_file':
        return os.path.join(TMP_DIR_PATH, OUT_FILENAME)
    elif filename == 'solution_file':
        return os.path.join(TMP_DIR_PATH, SOL_FILENAME)
    else:
        raise RuntimeError('invalid-tmp-file', filename)


def init_TMP_DIRECTORY():
    """Creates a folder where to store the temporary files needed by the service. Our goal is that this should work whether the service is run in local or on a server."""
    dir_path = get_path_of('tmp_directory')
    if not os.path.exists(dir_path):
        os.makedirs(dir_path)


def receive_modelling_files():
    """Enables the receipt of hte files sent by the bot and return the input of the input_file"""
    # Initialize TMP_DIRECTORY
    init_TMP_DIRECTORY()

    # Get files
    mod = service_server_requires_and_gets_file_of_handle('mod').decode()
    dat = service_server_requires_and_gets_file_of_handle('dat').decode()
    input = service_server_requires_and_gets_file_of_handle('input').decode()

    # Create in TMP_DIRECTORY mod file
    try:
        with open(get_path_of('mod_file'), 'w') as mod_file:
            mod_file.write(mod)
    except os.error as err:
        raise RuntimeError('write-error', MOD_FILENAME, err)

    # Create in TMP_DIRECTORY dat file
    try:
        with open(get_path_of('dat_file'), 'w') as dat_file:
            dat_file.write(dat)
    except os.error as err:
        raise RuntimeError('write-error', DAT_FILENAME, err)
    
    # return input
    return input


def run_GPLSOL():
    """launches glpsol on the .mod and .dat files contained in TMP_DIR. The output of glpsol is displayed on standard output. If with_output_file=True then the procedure expects a file 'output.txt' to be generated by glpsol in TMP_DIR and its format to comply sol_style. If not, the procedure warns the user and terminates the service. If 'output.txt' is valid then the solution is returned."""
    # Create in TMP_DIRECTORY output file
    try:
        with open(get_path_of('output_file'), 'w') as out_file:
            # RUN gplsol
            subprocess.run([
                "glpsol", 
                "-m", get_path_of('mod_file'), 
                "-d", get_path_of('dat_file')
            ], cwd=get_path_of('tmp_directory'), timeout=30.0, stdout=out_file)   
    except os.error as err:
        raise RuntimeError('write-error', MOD_FILENAME, err)
    except subprocess.TimeoutExpired as err:
        raise RuntimeError('process-timeout', err)
    except subprocess.CalledProcessError as err: 
        raise RuntimeError('process-call', err)
    except Exception as err:
        raise RuntimeError('process-exception', err)


def get_output_str():
    """Return a string that contents the output of GPLSOL."""
    try:
        with open(get_path_of('output_file'), 'r') as file:
            return file.read()
    except os.error as err:
        raise RuntimeError('output-read-error', err)


def get_raw_solution():
    """Return a list of string that contents the solution produced by GPLSOL. Remember to call a soluion_parsing function."""
    try:
        with open(get_path_of('solution_file'), 'r') as file:
            return file.read().splitlines()
    except os.error as err:
        raise RuntimeError('solution-read-error', err)


# TODO: fix PermissionError:
def clean_TMP_DIRECTORY():
    """Remove TMP_DIR"""
    os.remove(get_path_of('tmp_directory'))
