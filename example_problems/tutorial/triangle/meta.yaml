public_folder: public
services:
  gimme_instance:
    evaluator: [python, services/gimme_instance_driver.py]
    description: This service provides you with a random triangle of integer numbers. The argument n specifies the number of rows of the triangle. For i=1,...,n the i-th row of the triangle comprises i integers in the interval [MIN_VAL,MAX_VAL]. You can opt to insert the seed yourself, or ask the service to choose the seed (and hence the actual triangle <n,MIN_VAL,MAX_VAL,seed>).
    args:
      n:
        regex: ^([1-9][0-9]{0,1}|100)$
        explain: the number of rows of the triangle
        default: 5
      MIN_VAL:
        regex: ^(0|[1-9][0-9]{0,1})$
        explain: all numbers of the triangle are integers in the interval [MIN_VAL,MAX_VAL]
        default: 0
      MAX_VAL:
        regex: ^(0|[1-9][0-9]{0,1})$
        explain: all numbers of the triangle are integers in the interval [MIN_VAL,MAX_VAL]
        default: 99
      seed:
        explain: specify the numeric code (any integer in the interval [100000,999999]) to work with an already met pseudo-random instance. When this argument is left to its default value (random_seed) then the service chooses a seed at random, communicates it to the user, and works on the unique pseudo-random instance <n,MIN_VAL,MAX_VAL,seed>.
        regex: ^(random_seed|[1-9][0-9]{5,5})$
        default: random_seed
      silent:
        regex: ^(0|1)$
        explain: If this flag is set to 1 then only the bare instance will be printed. In this way, if you redirect the output of the rtal call to file (e.g., with > from the shell) you will get a valid instance file for the other services.
        default: 0
      # display:
      #   regex: ^(0|1)$
      #   default: 0
      #   explain: If this flag is set to 1 then the instance file is listed by the service.
      # download:
      #   regex: ^(0|1)$
      #   default: 0
      #   explain: 'If this flag is set to 1 then the instance file is downloaded in the \''download\'' sub-folder of the folder from which this TALight service call has been issued.'
      lang:
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it

  check_and_reward_one_sol:
    evaluator: [python, services/check_and_reward_one_sol_driver.py]
    description: this service checks whether a path descending from the top vertex is a feasible solution for a given triangle.
    args:
      n:
        regex: ^([1-9][0-9]{0,1}|100)$
        explain: the number of rows of the triangle
        default: 5
      MIN_VAL:
        regex: ^(0|[1-9][0-9]{0,1})$
        explain: all numbers of the triangle are integers in the interval [MIN_VAL,MAX_VAL]
        default: 0
      MAX_VAL:
        regex: ^(0|[1-9][0-9]{0,1})$
        explain: all numbers of the triangle are integers in the interval [MIN_VAL,MAX_VAL]
        default: 99
      how_to_input_the_triangle:
        regex: ^(my_own_triangle|([1-9][0-9]{5,5}))$
        explain: if you enter a seed (an integer in the range [100000,999999]) then the service acts on the pseudo-random triangle <n,MIN_VAL,MAX_VAL,seed>, which you might have previously encountered in previous calls to this or other services for this problem. Otherwise, if how_to_input_the_triangle=my_own_triangle, the service allows you to enter your own triangle.
        default: my_own_triangle
      path:
        regex: ^((L|R){0,99})$
        explain: "a solution for a given triangle instance is a path from the top vertex of the triangle to an element of its last (bottom) row. The path always has two options when moving from one row to the next: either go left (L) or right (R). Hence feasible paths are encoded as sequence in {{L,R}}^(n-1))."
      silent:
        explain: if silent=1 and nothing is wrong with your solution for the given triangle, then the service runs silently; otherwise either it confirms the validity of your path or explains what the problem is.
        regex: ^(0|1)$
        default: 0
      display_triangle:
        explain: when this flag is set to 1 then the triangle is displayed before providing any feedback on the path.
        regex: ^(0|1)$
        default: 1
      reward_the_path:
        explain: if this argument is set to 1 then your path in the triangle is rewarded with the sum of the integers contained in the visited positions of the triangle.
        regex: ^(0|1)$
        default: 1
      lang:
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it

  check_sol_optimality:
    evaluator: [python, services/check_best_sol_driver.py]
    description: for a given triangle of integer numbers, the problem triangle asks you to find a path descending from its top vertex while maximizing the sum of the numbers on the visited positions. If you think to know what the best value is, you can call this service for confirmation. You can also ask the service to tell you what the true optimum value is.
    args:
      n:
        regex: ^([1-9][0-9]{0,1}|100)$
        explain: the number of rows of the triangle
        default: 5
      MIN_VAL:
        regex: ^(0|[1-9][0-9]{0,1})$
        explain: all numbers of the triangle are integers in the interval [MIN_VAL,MAX_VAL]
        default: 0
      MAX_VAL:
        regex: ^(0|[1-9][0-9]{0,1})$
        explain: all numbers of the triangle are integers in the interval [MIN_VAL,MAX_VAL]
        default: 99
      how_to_input_the_triangle:
        regex: ^(my_own_triangle|([1-9][0-9]{5,5}))$
        explain: if you enter a seed (an integer in the range [100000,999999]) then the service acts on the pseudo-random triangle <n,MIN_VAL,MAX_VAL,seed>, which you might have previously encountered in previous calls to this or other services for this problem. Otherwise, if how_to_input_the_triangle=my_own_triangle, the service allows you to enter your own triangle.
        default: my_own_triangle
      opt_sol_val:
        regex: ^0|(|-)[1-9][0-9]{0,5}$
        default: 0
        explain: Use this argument to tell the service what you conjecture to be the maximum reward possible over all feasible paths. Leave this argument to its default value in case you have non conjecture and only intend to use this service to be told about the optimum value. A solution for a given triangle instance is a path from the top vertex of the triangle to an element of its last (bottom) row. Such a path is rewarded with the sum of the integers contained in the visited positions of the triangle. We are interested in maximizing this reward. 
      feedback:
        regex: ^(yes_no|bigger_or_smaller|true_opt_val)$
        default: yes_no
        explain: "the options are as follows:"
        explain1: -yes_no= just tell me whether <opt_sol_val> is or is not the optimal solution value.
        explain2: -bigger_or_smaller= tell me whether the optimal solution value is bigger or smaller than <opt_sol_val>, in case they differ.
        explain3: -true_opt_val= please, tell me the true optimal solution value.
      silent:  
        explain: if nothing is wrong with your solution for the triangle you have specified us (through seed) then the service runs silently; otherwise it explains what is the problem in clear.
        regex: ^(0|1)$
        default: 0
      lang:
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it

  check_feasible_solution:
    description: this service asks you to check whether the path we give you is a feasible solution for a given pseudo-random triangle.
    evaluator: [python, services/check_feasible_solution_driver.py]
    args:
      MIN_VAL:
        regex: ^(0|[1-9][0-9]{0,1})$
        explain: all numbers of the triangle are integers in the interval [MIN_VAL,MAX_VAL]
        default: 0
      MAX_VAL:
        regex: ^(0|[1-9][0-9]{0,1})$
        explain: all numbers of the triangle are integers in the interval [MIN_VAL,MAX_VAL]
        default: 99
      silent:  
        explain: if nothing is wrong with your answer then the service runs silently; otherwise it explains what is the problem in clear.
        regex: ^(0|1)$
        default: 0

  check_number_of_triangles_in_triangle:
    description: this service asks you to count how many times a given triangle fits inside a bigger triangle.
    evaluator: [python, services/check_number_of_triangles_in_triangle_driver.py]
    args:
      big_n:
        regex: ^([1-9][0-9]{0,1}|100)$
        explain: the number of rows of the bigger triangle if inserted by seed or manually
        default: 10
      small_n:
        regex: ^([1-9][0-9]{0,1}|100)$
        explain: the number of rows of the smaller triangle if inserted by seed or manually
        default: 2
      MIN_VAL:
        regex: ^([0-9])$
        explain: all numbers of the two triangles are integers in the interval [MIN_VAL,MAX_VAL]
        default: 0
      MAX_VAL:
        regex: ^([0-9])$
        explain: all numbers of the two triangles are integers in the interval [MIN_VAL,MAX_VAL]
        default: 1
      display_big:
        explain: when this flag is set to 1 then the big triangle is displayed.
        regex: ^(0|1)$
        default: 1
      display_small:
        explain: when this flag is set to 1 then the small triangle is displayed.
        regex: ^(0|1)$
        default: 1
      display_sol:
        explain: when this flag is set to 1 then the immersions of the small triangle into the big triangle are displayed.
        regex: ^(0|1)$
        default: 1
      how_to_input_the_big_triangle:
        regex: ^(my_own_triangle|([1-9][0-9]{5,5})|random)$
        explain: if you enter a seed (an integer in the range [100000,999999]) then the service acts on the pseudo-random triangle <n,MIN_VAL,MAX_VAL,seed>, which you might have previously encountered in previous calls to this or other services for this problem. If how_to_input_the_triangle=my_own_triangle, the service allows you to enter your own triangle. Otherwise, if how_to_input_the_triangle=random, the service provides you a triangle created by a pseudo-random seed. 
        default: random
      how_to_input_the_small_triangle:
        regex: ^(my_own_triangle|([1-9][0-9]{5,5})|random)$
        explain: if you enter a seed (an integer in the range [100000,999999]) then the service acts on the pseudo-random triangle <n,MIN_VAL,MAX_VAL,seed>, which you might have previously encountered in previous calls to this or other services for this problem. If how_to_input_the_triangle=my_own_triangle, the service allows you to enter your own triangle. Otherwise, if how_to_input_the_triangle=random, the service provides you a triangle created by a pseudo-random seed. 
        default: random
      silent:  
        explain: if nothing is wrong with your answer then the service runs silently; otherwise it explains what is the problem in clear.
        regex: ^(0|1)$
        default: 0

  eval_feasible_sol:
    evaluator: [python, services/eval_feasible_sol_driver.py]
    description: "this service evaluates your code which has to provide a feasible solution for a given triangle of integer numbers. A feasible soluton is a descending path in the triamgle starting from the top vertex and reaching on element inthe last row. This path visits precisely one element for each of the n rows of the triangle and we assume it is encoded as a sequence in {L,R}^(n-1) (regex: (L|R){n-1,n-1}), where the i-th symbol of the sequence specifies whether the path turns Left or Right at the i-th step."
    args:
      goal:
        explain: set your goal (efficient includes also correct).
        regex: ^(correct|time_at_most_2_exp_n|time_at_most_n_exp_2)$
        default: correct
      code_lang: 
        explain: the more we know about your bot the better we can estimate the efficiency of your algorithm.
        regex: ^(python|java|nodejs|compiled)$
        default: python

  eval_and_reward_one_sol:
    description: this service evaluates your code which calculates the reward for a given path in a triangle.
    evaluator: [python, services/eval_and_reward_one_sol_driver.py]
    args:
      goal:
        explain: set your goal (efficient includes also correct).
        regex: ^(correct|time_at_most_2_exp_n|time_at_most_n_exp_2)$
        default: correct
      code_lang: 
        explain: the more we know about your bot the better we can estimate the efficiency of your algorithm.
        regex: ^(python|java|nodejs|compiled)$
        default: python

  eval_best_sol:
    description: this service evaluates your code which calculates the maximum reward collectable by a path descending in a triangle.
    evaluator: [python, services/eval_best_sol_driver.py]
    args:
      goal:
        explain: set your goal (efficient includes also correct).
        regex: ^(correct|time_at_most_2_exp_n|time_at_most_n_exp_2)$
        default: correct
      check_also_sol:
        explain: when this flag is set to 1 then the service expects and checks also the solution, not only its value.
        regex: ^(0|1)$
        default: 0
      code_lang: 
        explain: the more we know about your bot the better we can estimate the efficiency of your algorithm.
        regex: ^(python|java|nodejs|compiled)$
        default: python
      seed:
        explain: specify the numeric code (any integer in the interval [100000,999999]) to replicate the very same behaviour as in a previous call to this service. When this argument is left to its default value (random_seed) then the service chooses a seed at random, communicates it to the user, and proceeds deterministically from that seed.
        regex: ^(random_seed|[1-9][0-9]{5,5})$
        default: random_seed

  eval_number_of_triangles_in_triangle:
    description: this service evaluates your code which takes in input two triangles and calculates the number of occurences of the small triangle withing the big one.
    evaluator: [python, services/eval_number_of_triangles_in_triangle_driver.py]
    args:
      goal:
        explain: set your goal (efficient includes also correct).
        regex: ^(correct|time_at_most_2_exp_n|time_at_most_n_exp_2)$
        default: correct
      code_lang: 
        explain: the more we know about your bot the better we can estimate the efficiency of your algorithm.
        regex: ^(python|java|nodejs|compiled)$
        default: python

  synopsis:
    evaluator: [python, services/synopsis/synopsis_driver.py]
    args:
      service:
        regex: ^((\S)+)$
        default: synopsis
        explain: any string without space characters meaning one of the services of the problem {problem}
      lang:
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: hardcoded
      metafile:
        regex: ^(main|en|it)$
        default: main
...
