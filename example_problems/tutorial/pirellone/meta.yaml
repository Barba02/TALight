public_folder: public
services:
  compact_solution:
    explain: "We give you a matrix and a sequence of switch rows/columns operations that leads to the all 0 matrix. You are required to shorten this sequence."
    evaluator: [python,services/compact_solution_server.py]
    args:
      seed:
        explain: "specify the numeric code to reproduce the very same psudo-random instance as in a previous run. Called with seed=random_seed, the service chooses its seed at random (and communicates it to the user)."
        regex: ^(random_seed|[1-9][0-9]{5,5})$
        default: random_seed
      m:
        regex: ^([1-9][0-9]{0,1})$
        default: 4
        explain: "Number of rows of the pirellone."
      n:
        regex: ^([1-9][0-9]{0,1})$
        default: 4
        explain: "Number of columns of the pirellone."
      goal:
        regex: ^(m_plus_n|m_plus_n_half|min)$
        default: m_plus_n
        explain: "Set an upper-bound on the length of your solution. The choiches are as follows:"
        explain1: "[m_plus_n]  yield a solution with at most m+n moves."
        explain2: "[m_plus_n_half]  yield a solution with at most (m+n)/2 moves."
        explain3: "[min]  yield a solution with the minimum possible number of moves."
      level:
        regex: ^(easy|medium|difficult)$
        default: medium
        explain: "Level of the exercise."
      lang:
        regex: ^(hardcoded|en|it)$
        default: it
  order_of_rows_columns:
    explain: "You are asked to prove that the solvability of a 0/1-matrix is invariant under permutation of its rows (or columns). We give you a good 0/1-matrix and a sequence of switch row/column operations turnig it off (a certificate of goodness). We also give you a permutation of the rows and a permutation of the columns of the matrix. You are required to give us a certificate of goodness for the permuted matrix."
#    example: "rtal connect pirellone -am=2 -an=3\\n1 0 1\\n0 1 0\\nr1 c2\\n2 1\\n3 2 1\\n>r2 c2"
    example: "rtal connect pirellone -am=2 -an=3"
    example1: "> 1 0 1"
    example2: "> 0 1 0"
    example3: "> r1 c2"
    example4: "> 2 1"
    example5: "> 3 2 1"
    example6: "< r2 c2"
    evaluator: [python, services/order_of_rows_columns_server.py]
    args:
      m:
        regex: ^([1-9][0-9]{0,1})$
        default: 10
        explain: "Number of rows of the big matrix."
      n:
        regex: ^([1-9][0-9]{0,1})$
        default: 10
        explain: "Number of columns of the big matrix."
      seed:
        explain: "specify the numeric code to reproduce the very same psudo-random instance as in a previous run. Called with seed=random_seed, the service chooses its seed at random (and communicates it to the user)."
        regex: ^(random_seed|[1-9][0-9]{5,5})$
        default: random_seed
      lang:
        regex: ^(hardcoded|en|it)$
        default: it
  sub_closure:
    explain: "You are asked to prove that a 0/1-matrix containing a bad submatrix is also bad. We give you a good 0/1-matrix and a sequence of swich row/column operations turnig it off (a certificate of goodness). You are required to give us a certificate of goodness for a 0/1-submatrix specified by us."
    evaluator: [python, services/sub_closure_server.py]
    args:
      m:
        regex: ^([1-9][0-9]{0,1})$
        default: 10
        explain: "Number of rows of the big matrix."
      n:
        regex: ^([1-9][0-9]{0,1})$
        default: 10
        explain: "Number of columns of the big matrix."
      submatrix_type:
        regex: ^(consecutive|any)$
        default: consecutive
        explain: "Type of submatrix."
        explain1: "[consecutive]  the submatrix comprises the first m_small rows and the first n_small columns of the big matrix. See also the service order_of_rows_columns to see why this is actually a general consecutive submatrix."
        explain2: "[any]  the service server provides two random 0/1-vectors of length m and n, respectively. These characteristic vectors specify the rows and columns of the submatrix."
      seed:
        explain: "specify the numeric code to reproduce the very same psudo-random instance as in a previous run. Called with seed=random_seed, the service chooses its seed at random (and communicates it to the user)."
        regex: ^(random_seed|[1-9][0-9]{5,5})$
        default: random_seed
      lang:
        regex: ^(hardcoded|en|it)$
        default: it
  check_unsol:
    evaluator: [python, services/check_unsol_server.py]
    explain: "You provide a matrix that you believe to be unsolvable (or minimal/minimum unsolvable). The service checks its unsolvability (or your stronger assertion). In case your matrix is not unsolvable, You can also check the minimality of your unsolvable matrix."
    args:
      assertion:
        regex: ^(any|minimal|minimum)$
        default: any
        explain: "Set your goal. You can choose the type of unsolvability related to the size of the matrix."
      with_certificate:
        regex: ^(0|1)$
        default: 0
        explain: "if this flag is set to 1 and your assertion is false, then the service offers evidence of the fault."
      lang:
        regex: ^(hardcoded|en|it)$
        default: it
  check_sol:
    explain: "The service checks your solution for an instance (either provided by you or generated at random). You can even call this service on an already encountered solvable random instance (also met with other services): a solvable random instance can be reconstructed from m, n, and its random seed."
    evaluator: [python, services/check_sol_server.py]
    args:
      seed:
        explain: "specify the numeric code to reproduce the very same psudo-random instance as in a previous run. Called with seed=random_seed, the service chooses its seed at random (and communicates it to the user)."
        regex: ^(random_seed|[1-9][0-9]{5,5})$
        default: random_seed
      coding:
        regex: ^(seq|subset)$
        default: seq
        explain: "seq: list of commands for example r1 c3 r4, subset is two string of 1,0 as long as the number of rows and columns that indicate which switch is on or off. "
        example: "seq: r2 c4 r3 r1, subset: 1 0 1, 0 1 1 if the matrix is 3x3 "
      lang:
        regex: ^(hardcoded|en|it)$
        default: it
  eval_decision:
    evaluator: [python, services/eval_decision_server.py]
    args:
      goal:
        regex: ^(correct|efficient)$
        default: correct
        explain: "Set your goal (efficient includes also correct)."
      with_check_of_sol:
        regex: ^(0|1)$
        default: 0
        explain: if this flag is set to 1 then, for the yes instances, you should also provide a solution which will be checked by the service.
      seed:
        explain: "specify the numeric code to reproduce the very same set of instances as in a previous run. Called with seed=random_seed, the service chooses its seed at random (and communicates it to the user)."
        regex: ^(random_seed|[1-9][0-9]{5,5})$
        default: random_seed
      lang:
        regex: ^(hardcoded|en|it)$
        default: it
  eval_sol:
    explain: si basa su un dialogo dove il bot chiede il valore di alcune entris prima di tornar la soluzione.
    evaluator: [python, services/eval_sol_server.py]
    args:
      goal:
        regex: ^(correct|polynomial_in_m|efficient|sub_linear)$
        default: correct
        explain: "Set your goal from the following total order"
        explain1: "[correct]  bla bla"
      seed:
        explain: "specify the numeric code to reproduce the very same set of instances as in a previous run. Called with seed=random_seed, the service chooses its seed at random (and communicates it to the user)."
        regex: ^(random_seed|[1-9][0-9]{5,5})$
        default: random_seed
      lang:
        regex: ^(hardcoded|en|it)$
        default: it
  trilly:
    evaluator: [python, services/trilly_server.py]
    explain: "Trilly the fairy helps you understand whether and how you can solve a 0/1-matrix."
    args:
      size:
        regex: ^(small|medium|large|huge|unbearable)$
        default: medium
        explain: "You can choose the size of the random matrix."
      num_calls:
        regex: ^([1-9]{0,1})$
        default: 2
        explain: "Number of step to find the solution."
      lang:
        regex: ^(hardcoded|en|it)$
        default: it
  synopsis:
    evaluator: [python, services/synopsis/synopsis_server.py]
    args:
      service:
        regex: ^((\S)+)$
        default: synopsis
      lang:
        regex: ^(hardcoded|en|it)$
        default: it

