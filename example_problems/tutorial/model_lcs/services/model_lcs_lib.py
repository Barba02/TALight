#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# from tabulate import tabulate
import pandas as pd
import copy
import random
import re
import networkx as nx

import string

### CONSTANTS #########################################
FORMAT_AVAILABLES = ['dat', 'txt']
DAT_STYLES_AVAILABLES = ['']
TXT_STYLES_AVAILABLES = ['only_strings', 'with_m_and_n']
DEFAULT_FORMAT='only_strings.txt'
#######################################################


# CONVERTERS FUNCTIONS:
def subset_to_subsequence(subset_sol):
    """Convert subset solution (e.g.: [[0,1],[0,0,1]]) into sequence solution (e.g.: ['r2','c3'])"""
    m = len(subset_sol[0])
    n = len(subset_sol[1])
    seq_sol = list()
    for i in range(m):
        if subset_sol[0][i]:
            seq_sol.append(f"r{i+1}")
    for j in range(n):
        if subset_sol[1][j]:
            seq_sol.append(f"c{j+1}")
    return seq_sol


def seq_to_subset(seq_sol, m, n):
    """Convert sequence solution (e.g.: ['r2','c3']) into subset solution (e.g.: [[0,1],[0,0,1]])"""
    assert isinstance(seq_sol, list)
    subset_sol = [[0]*m,[0]*n]
    for e in seq_sol:
        if e[0] == 'r':
            subset_sol[0][int(e[1:])-1] = (1-subset_sol[0][int(e[1:])-1])
        elif e[0] == 'c':
            subset_sol[1][int(e[1:])-1] = (1-subset_sol[1][int(e[1:])-1])
        else:
            raise RuntimeError(f'This seq_sol is bad written: {seq_sol}')
    return subset_sol


def process_user_sol(ENV, TAc, LANG, raw_sol, m, n):
    """Parse this raw_sol with sol_style and return the solution in correct format."""
    assert ENV['sol_style'] in ["subsequence","annotated_seq"], f"ENV['sol_style']={ENV['sol_style']}?!"
    # Case1: subsequence style
    sol = list()
    if ENV['sol_style'] == 'subsequence':
        if len(raw_sol) != 1:
            TAc.print(LANG.render_feedback('solution-too-many-lines', "The solution.txt file generated by your model contains {len(raw_sol)} lines instead of 2 lines."), "red", ["bold"])
            exit(0)
        # Checks no moves
        if raw_sol[0] == '':
            return sol
        sol = raw_sol[0].split()
        move_regex = "^((r|R|c|C)[1-9][0-9]*)$"
        for e in sol: 
            if any(not re.match(move_regex, e) for e in sol):
                TAc.print(LANG.render_feedback('unrecognized-move', "The solution.txt file generated by your model contains the unsecognized move {e} which does not match the regex {move_regex}."), "red", ["bold"])
                exit(0)
            # Checks rows
            if (e[0] in ['r', 'R']) and (int(e[1:]) > m):
                TAc.print(LANG.render_feedback('row-index-overflow', "The solution.txt file generated by your model contains the move {e} which is invalid since the given matrix has only {m} rows."), "red", ["bold"])
                exit(0)
            # Checks cols
            if (e[0] in ['c', 'C']) and (int(e[1:]) > n):
                TAc.print(LANG.render_feedback('col-index-overflow', "The solution.txt file generated by your model contains the move {e} which is invalid since the given matrix has only {n} rows."), "red", ["bold"])
        return sol
    
    # Case2: subset style
    elif ENV['sol_style'] == 'subset':
        if len(raw_sol) != 2:
            TAc.print(LANG.render_feedback('subset-solution-too-many-lines', "The solution.txt file generated by your model contains {len(raw_sol)} lines instead of 2 lines."), "red", ["bold"])
            exit(0)
        # Check rows
        rows_switch = raw_sol[0].split()
        if len(rows_switch) != m:
            TAc.print(LANG.render_feedback('wrong-len-rows', "The first line of the solution.txt file generated by your model ({rows_switch}) contains {len(rows_switch)} tokens rather than {m}."), "red", ["bold"])
            exit(0)
        if any([not re.match(f"^(0|1)$", e) for e in rows_switch]):
            TAc.print(LANG.render_feedback('wrong-token1', "The first line of the solution.txt file generated by your model ({rows_switch}) contains a token ({e}) that is neither a 0 nor a 1."), "red", ["bold"])
            exit(0)
        sol.append([int(e) for e in rows_switch])
        # Check cols
        cols_switch = raw_sol[1].split()
        if len(cols_switch) != n:
            TAc.print(LANG.render_feedback('wrong-len-cols', "The second line of the solution.txt file generated by your model ({cols_switch}) contains {len(cols_switch)} tokens rather than {n}."), "red", ["bold"])
            exit(0)
        if any([not re.match(f"^(0|1)$", e) for e in cols_switch]):
            TAc.print(LANG.render_feedback('wrong-token2', "The second line of the solution.txt file generated by your model ({cols_switch}) contains a token ({e}) that is neither a 0 nor a 1."), "red", ["bold"])
            exit(0)
        sol.append([int(e) for e in cols_switch])
        return sol
    

# TO STRING
def annotated_subseq_to_str(solution):
    return ('\n'.join([f'{solution.get(key)} {key[0]} {key[1]}' for key in sorted(solution)]))

def subsequence_to_str(sequence):
    return " ".join(sequence.get(key) for key in sorted(sequence))

def sequence_to_str(sequence):
    return " ".join(e for e in sequence)

def seq_to_str(seq_sol):
    """From a sequence solution (e.g.: ['r2']) returns its string form (e.g.: 'r2')"""
    return ' '.join(seq_sol)


def sol_to_str(matrix, subset_sol):
    """Print the matrix instance with the rows and cols to be switches"""
    m = len(matrix)
    n = len(matrix[0])
    sol_str = '    ' + ' '.join(str(e) for e in subset_sol[1]) + '\n'
    sol_str += f'    {"-" * (len(subset_sol[1]*2)-1)}\n'
    for i in range(m):
        sol_str += f'{subset_sol[0][i]} | '
        sol_str += ' '.join(str(e) for e in matrix[i]) + '\n'
    return sol_str[:-1]


def subset_to_str(subset_sol):
    sol = subset_to_str_list(subset_sol)
    return sol[0] + '\n' + sol[1]


def subset_to_str_list(subset_sol):
    """From a subset solution (e.g.: [[0,1],[0,0]]) returns a list with the rows string and the columns string (e.g.: ['0 1', '0 0']) or NO_SOL"""
    return [' '.join([str(e) for e in subset_sol[0]]), \
            ' '.join([str(e) for e in subset_sol[1]])]


def instance_to_str(problem, format='default'):
    """This function returns the string representation of the given two strings instance according to the indicated format"""
    # Get default
    format = DEFAULT_FORMAT if format=='default' else format
    # Parsing format
    format_list = format.split('.')
    if len(format_list) == 1:
        format_primary = format_list[0]
        format_secondary = ''
    else:
        format_primary = format_list[1]
        format_secondary = format_list[0]
    # Get problem in str format
    assert format_primary in FORMAT_AVAILABLES, f'Value [{format_primary}] unsupported for the argument format_primary.'
    if format_primary == 'dat':
        return instance_to_dat(problem, format_secondary)
    if format_primary == 'txt':
        return instance_to_txt(problem, format_secondary)


def instance_to_txt(problem, style='only_strings'):
    """This function returns the string representation of the given two strings instance according to the indicated style"""
    assert style in TXT_STYLES_AVAILABLES, f'Value [{style}] unsupported for the argument format_secondary when format_primary=txt'
    return '\n'.join(sequence_to_str(string) for string in problem)


def instance_to_dat(problem, style=''):
    """This function returns the dat representation of the given two strings instance according to the indicated style"""
    assert style in DAT_STYLES_AVAILABLES, f'Value [{style}] unsupported for the argument format_secondary when format_primary=txt'
    M = len(problem[0])
    N = len(problem[1])
    output = f"param M := {M};  # Number of characters of the first string\n"
    output += f"param N := {N};  # Number of characters of the second string\n"
    output += "param: STRINGS: FIRST_STRING    SECOND_STRING :=\n"
    for j in range(max(M, N)):
        if j < M and j < N:
            output += f'            {j+1} {problem[0][j]}             {problem[1][j]}\n'
        elif j >= M:
            output += f'            {j+1} .               {problem[1][j]}\n'
        elif j >= N:
            output += f'            {j+1} {problem[0][j]}             .\n'
    output = output[:-1] + ";\nend;"
    return output


# FROM STRING
def get_instance_from_str(problem, format):
    """This function returns the string representation of the given two string instances according to the indicated format."""
    # Parsing format
    format_list = format.split('.')
    if len(format_list) == 1:
        format_primary = format_list[0]
        format_secondary = ''
    else:
        format_primary = format_list[1]
        format_secondary = format_list[0]
    # Get two strings in str format
    assert format_primary in FORMAT_AVAILABLES, f'Value [{format_primary}] unsupported for the argument format_primary.'
    if format_primary == 'dat':
        return get_instance_from_dat(problem, format_secondary)
    if format_primary == 'txt':
        return get_instance_from_txt(problem, format_secondary)


def get_instance_from_txt(problem, style='only_strings'):
    """This function returns the string representation of the given two strings instance according to the indicated format."""
    assert style in TXT_STYLES_AVAILABLES, f'Value [{style}] unsupported for the argument format_secondary when format_primary=txt'
    instance = list()
    lines = problem.split('\n')
    if style == "with_m_and_n":
        lines = lines[1:]
    for line in lines:
        if len(line) != 0:
            instance.append(line.split())
    return instance


def get_instance_from_dat(problem, style=''):
    """This function returns the string representation of the given two strings instance according to the indicated format."""
    assert style in DAT_STYLES_AVAILABLES, f'Value [{style}] unsupported for the argument format_secondary when format_primary=txt'
    instance = list()
    instance.append(list())
    instance.append(list())
    # Get lines
    lines = problem.split('\n')
    # Parse lines
    for line in lines:
        line = line.strip() # remove whitespace before and after
        # Filter the problem lines
        if line != '' and line[:5] != 'param' and line[:3] != 'end':
            line = line.replace(';', '') #ignore ;
            line = line.split()
            if line[1] != '.':
                instance[0].append((line[1]))
            if line[-1] != '.':
                instance[1].append((line[-1]))
    return instance


# INSTANCE GENERATOR FUNCTIONS:
def gen_instance(m:int,n:int,alphabet:str,seed:int):
    assert m >= 0
    assert n >= 0
    instance_alphabet = get_alphabet(alphabet)
    random.seed(seed)
    problem = []
    problem.append([random.choice(instance_alphabet) for i in range(m)])
    problem.append([random.choice(instance_alphabet) for i in range(n)])
    return problem


# CORE FUNCTIONS:
def get_alphabet(alphabet):
    if alphabet == "lowercase":
        return string.ascii_lowercase
    elif alphabet == "lowercase_uppercase":
        return string.ascii_letters
    else: # alphabet == "dna"
        return "ACGT"


def get_sol(s, t, m, n, sol_style="length"):
    risp = [[0]*(n+1) for _ in range(m+1)]
    for i in range(m):
        for j in range(n):
            if s[i] == t[j]:
                risp[i+1][j+1] = 1 + risp[i][j]
            else:
                risp[i+1][j+1] = max(risp[i+1][j],risp[i][j+1])
    if sol_style == "length":
        return risp[m][n]
    else:
        solution = {}
        while m > 0 and n > 0:
            if s[m-1] == t[n-1]:
                solution[(m-1, n-1)] = s[m-1]
                m-=1
                n-=1
            elif risp[m-1][n] > risp[m][n-1]:
                m-=1
            else:
                n-=1
        return solution


def check_input(TAc, LANG, ENV, line):
    if line[0] not in string.ascii_letters:
        TAc.print(LANG.render_feedback('error-first-not-character', '#ERROR: The first element must be the single common character.'), 'red', ['bold'])
        exit(0)
    if line[1] not in string.digits:
        TAc.print(LANG.render_feedback('error-second-not-digit', '#ERROR: The second element must be a digit, corresponding to the index of the common character in the first string.'), 'red', ['bold'])
        exit(0)
    if line[2] not in string.digits:
        TAc.print(LANG.render_feedback('error-third-not-digit', '#ERROR: The third element must be a digit, corresponding to the index of the common character in the second string.'), 'red', ['bold'])
        exit(0)
    if int(line[1]) not in range(ENV['m']):
        TAc.print(LANG.render_feedback('error-second-not-index', f"#ERROR: The second element must be the index of the single common character in the first string. Must be in the range {{0, {ENV['m']}}}."), 'red', ['bold'])
        exit(0)
    if int(line[2]) not in range(ENV['n']):
        TAc.print(LANG.render_feedback('error-second-not-index', f"#ERROR: The second element must be the index of the single common character in the first string.. Must be in the range {{0, {ENV['n']}}}."), 'red', ['bold'])
        exit(0)
    return True


def check_sol(TAc, LANG, ENV, user_sol, s, t):
    sol = get_sol(s, t, len(s), len(t))
    if sol != len(user_sol):
        TAc.print(LANG.render_feedback('error-wrong-sol', f'#ERROR: Your solution differs from the correct one. Your length is {len(user_sol)}, the correct solution length is {sol}.'), 'red', ['bold'])
        exit(0) 
    if ENV['sol_style'] == 'subsequence':
        i = 0
        j = 0
        for char in user_sol:
            s_found = True
            t_found = True
            while i < len(s) and s_found:
                if char == s[i]:
                    s_found = False
                i += 1
            while j < len(t) and t_found:
                if char == t[j]:
                    t_found = False
                j += 1
            if s_found:
                TAc.print(LANG.render_feedback('error-no-matching-char', f'#ERROR: Your solution include a character ({char}) which is not included in the one of the first string.'), 'red', ['bold'])
                exit(0)
            if t_found:
                TAc.print(LANG.render_feedback('error-no-matching-char', f'#ERROR: Your solution include a character ({char}) which is not included in the one of the second string.'), 'red', ['bold'])
                exit(0)
    if ENV['sol_style'] == 'annotated_subseq':
        sorted_keys = sorted(user_sol)
        temp_s = -1
        temp_t = -1
        for pair in sorted_keys:
            if pair[0] == temp_s:
                TAc.print(LANG.render_feedback('error-index-s-duplicate', f'#ERROR: The index {pair[0]} has been referenced twice. You can select a character of a string just one time.'), 'red', ['bold'])
                exit(0)
            if pair[1] == temp_t:
                TAc.print(LANG.render_feedback('error-index-t-duplicate', f'#ERROR: The index {pair[1]} has been referenced twice. You can select a character of a string just one time.'), 'red', ['bold'])
                exit(0)
            if pair[1] < temp_t:
                TAc.print(LANG.render_feedback('error-index-t-unordered', f'#ERROR: The index {pair[1]} is lower than the previous index {temp_t}, but indexes, for both s and t string, must be referenced once and in non decreasing order.'), 'red', ['bold'])
                exit(0)
            if s[pair[0]] != user_sol.get(pair):
                TAc.print(LANG.render_feedback('error-s-no-matching-char', f'#ERROR: The char in position {pair[0]} of the first string is not: {s[pair[0]]}'), 'red', ['bold'])
                exit(0)
            if user_sol.get(pair) != t[pair[1]]:
                TAc.print(LANG.render_feedback('error-t-no-matching-char', f'#ERROR: The char in position {pair[1]} of the second string is not: {t[pair[1]]}'), 'red', ['bold'])
                exit(0) 
            temp_s = pair[0]
            temp_t = pair[1]
    return True

def visualizza(matrix):
    index=pd.Index([str(i) for i in range(len(matrix))])
    df=pd.DataFrame(matrix,index=index)
    df = df.iloc[0:,0:]
    columns=["-"]+[str(i) for i in range(len(matrix[0])+10)]
    print(tabulate(df, headers=columns, tablefmt='fancy_grid'))
    
def conta_num_met_in(matrix):
    num_met=0
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            if matrix[i][j]==1:
                num_met+=1
    return num_met
        
def spara_r(matrix,r):
    num_met_destroyed=0
    for j in range(len(matrix[0])):
        if matrix[r-1][j]==1:
            num_met_destroyed+=1
            matrix[r-1][j]=0
    return num_met_destroyed

def spara_c(matrix,c):
    num_met_destroyed=0
    for i in range(len(matrix)):    
        if matrix[i][c-1]==1:
            num_met_destroyed+=1
            matrix[i][c-1]=0
    return num_met_destroyed
        
def is_feasible_shooting(m:int,n:int,matrix_original,beams,silent:bool,TAc,LANG):
    """verifyies whether a set of laser beams is enough to destroy all the asteroids. Returns either True or False. When the arg silent=False then it also prints out about its findings."""
    matrix_after_moves=copy.deepcopy(matrix_original)
    num_met_destroyed=0
    for tipo_sparo, pos_sparo in beams:
        pos_sparo = int(pos_sparo)
        if tipo_sparo=='r':
            if pos_sparo < 1 or pos_sparo > m:
                TAc.print(LANG.render_feedback("wrong-row", f"You shoot on the row {pos_sparo} but the row indexes go from 0 to {len(matrix_original)-1}."), "red", ["bold"])    
            num_met_destroyed+=spara_r(matrix_after_moves,pos_sparo)
        if tipo_sparo=='c':
            if pos_sparo < 1 or pos_sparo > n:
                TAc.print(LANG.render_feedback("wrong-col", f"You shoot on the column {pos_sparo} but the column indexes go from 0 to {len(matrix_original[0])-1}."), "red", ["bold"])
            num_met_destroyed+=spara_c(matrix_after_moves,pos_sparo)
    if conta_num_met_in(matrix_after_moves)==0:
        if not silent:
            TAc.OK()
            TAc.print(LANG.render_feedback("feasible-shooting", "Congrats. You destroyed all asteroids and saved the world!"), "green", ["bold"])
        return True
    else:
        if not silent:
            TAc.NO()
            TAc.print(LANG.render_feedback("unfeasible-shooting", "You didn't destroyed all the asteroids. See the situation after shooting your laser beams:"), "red", ["bold"])
            visualizza(matrix_after_moves)
        return False


def is_optimal_shooting(m:int,n:int,matrix,beams,silent:bool,TAc,LANG):
    """given a set of laser beams which are assumed to be enough to destroy all the asteroids, this procedure returns True if this set has minimum possible cardinality, or False otherwise. When the arg silent=False then it also prints out about its findings."""
    assert is_feasible_shooting(m,n,matrix,beams,silent=True,TAc=TAc,LANG=LANG)
    if len(beams)==opt_val(m,n,matrix):
        if not silent:
            TAc.OK()
            TAc.print(LANG.render_feedback("optimal-shooting", "You destroyed all asteroids using a minimum possible number of laser beams."), "green", ["bold"])
        return True
    else:
        if not silent:
            TAc.NO()
            TAc.print(LANG.render_feedback("feasible-but-not-optimal-shooting", "You destroyed all asteroids but you didn't use the minimum number of laser beams."), "red", ["bold"])
        return False
            
def presenza_in_rig(asteroids):
    righe=[]
    for r,c in asteroids:
        if r not in righe:
            righe.append(r)
        else:
            return True
        
def presenza_in_col(asteroids):
    col=[]
    for r,c in asteroids:
        if c not in col:
            col.append(c)
        else:
            return True        
        

def max_match(m:int,n:int,matrix):
    G = nx.Graph()
    for i in range(m):
        G.add_node(f'r{i+1}',label=f'r{i+1}')
    for j in range(n):
        G.add_node(f'c{j+1}',label=f'c{j+1}')
    
    for i in range(m):
        for j in range(n):
            if matrix[i][j]==1:
                G.add_edge(f'r{i+1}',f'c{j+1}')
    return nx.maximum_matching(G)   #return nx.max_weight_matching(G)

def max_match_bip(m:int,n:int,matrix):
    G = nx.Graph()
    G.add_nodes_from([f'r{i+1}' for i in range(m)], bipartite=0)
    G.add_nodes_from([f'c{j+1}' for j in range(n)], bipartite=1)
    G.add_edges_from([(f'r{i+1}',f'c{j+1}') for i in range(m) for j in range(n) if matrix[i][j]==1])
    return nx.bipartite.maximum_matching(G)

def min_cover(m:int,n:int,matrix):
    G = nx.Graph()
    row_nodes = {f'r{i+1}' for i in range(m)}
    col_nodes = {f'c{j+1}' for j in range(n)}
    G.add_nodes_from(row_nodes, bipartite=0)
    G.add_nodes_from(col_nodes, bipartite=1)
    G.add_edges_from([(f'r{i+1}',f'c{j+1}') for i in range(m) for j in range(n) if matrix[i][j]==1])
    #print(G.nodes)
    #print(G.edges)
    matching = nx.bipartite.maximum_matching(G)
    #print(nx.bipartite.to_vertex_cover(G, matching, col_nodes))
    return nx.bipartite.to_vertex_cover(G, matching, col_nodes)

def max_independent_set(m:int,n:int,matrix):
    max_ind_set = []
    for key, value in max_match_bip(m,n,matrix).items():
        if key[0] == 'r':
            max_ind_set.append((int(key[1:]),int(value[1:])))
    return max_ind_set

def opt_val(m:int,n:int,matrix):
    return len(max_match_bip(m,n,matrix))//2

def check_row_index(index:int,m:int,TAc,LANG):
    if index < 1 or index > m:
        TAc.print(LANG.render_feedback("row-index-out-of-range", f"Row index {index} falls outside the valid range [0,{m-1}].", {"m":m}), "red", ["bold"])
        return False
    return True
                
def check_col_index(index:int,n:int,TAc,LANG):
    if index < 1 or index > n:
        TAc.print(LANG.render_feedback("col-index-out-of-range", f"Column index {index} falls outside the valid range [0,{n-1}].", {"n":n}), "red", ["bold"])
        return False
    return True
                
def check_is_cell_containing_asteroid(row_index:int,col_index:int,matrix,TAc,LANG):
    if not check_row_index(row_index,len(matrix),TAc,LANG):
        return False
    if not check_col_index(row_index,len(matrix[0]),TAc,LANG):
        return False
    if matrix[row_index-1][col_index-1] != 1:
        TAc.print(LANG.render_feedback("no-asteroid-cell", f"The cell ({row_index},{col_index}) contains no asteroid."), "red", ["bold"])
        return False 
    return True
                
def check_one_move_seq(move:str,m:int,n:int,TAc,LANG):
    if move.strip()=="":
        return True

    if move[0].upper()=="R":
        return check_row_index(int(move[1:]),m,TAc,LANG)
    else:
        return check_col_index(int(move[1:]),n,TAc,LANG)

def is_feasible_asteroid_set(m:int,n:int,matrix,asteroids,silent:bool,TAc,LANG):
    """verifyies whether the asteroids of a given subset are independent. Returns either True or False. When the arg silent=False then it also prints out about its findings."""
    occupied_row = [False] * m
    occupied_col = [False] * n
    for i,j in asteroids:
        if i < 1 or i > m:
            TAc.print(LANG.render_feedback("row-index-out-of-range", f"You pointed to the cell ({i},{j}) but the row indexes go from 1 to {m}."), "red", ["bold"])
            return False     
        if j < 0 or j >= n:
            TAc.print(LANG.render_feedback("col-index-out-of-range", f"You pointed to the cell ({i},{j}) but the column indexes go from 1 to {n}."), "red", ["bold"])
            return False 
        if matrix[i-1][j-1] != 1:
            TAc.print(LANG.render_feedback("no-asteroid-cell", f"You wrote the cell ({i},{j}) but this cell contains no asteroid."), "red", ["bold"])
            return False 
        if occupied_row[i]:
            TAc.print(LANG.render_feedback("two-asteroids-on-a-same-row", f"The row r{i} contains more than one asteroid."), "red", ["bold"])
            return False
        occupied_row[i] = True
        if occupied_col[j]:
            TAc.print(LANG.render_feedback("two-asteroids-on-a-same-col", f"The column c{j} contains more than one asteroid."), "red", ["bold"])
            return False
        occupied_col[j] = True
    if not silent:
        TAc.OK()
        TAc.print(LANG.render_feedback("feasible-asteroid-set", "Congrats. Your set of asteroids is feasible."), "green", ["bold"])
    return True

    
def is_optimal_asteroid_set(m:int,n:int,matrix,asteroids,silent:bool,give_a_better_solution_if_any:bool,TAc,LANG):
    """given a subset of the cells of matrix which are assumed to contain asteroids and be independent, this procedure returns True if this set has maximum possible cardinality, or False otherwise. When the arg silent=False then it also prints out about its findings."""
    assert is_feasible_asteroid_set(m,n,matrix,asteroids,silent=True,TAc=TAc,LANG=LANG)
    if len(asteroids)==opt_val(m,n,matrix):
        if not silent:
            TAc.OK()
            TAc.print(LANG.render_feedback("optimal-asteroid-set", "Your set of independent asteroids is of maximum cardinality possible."), "green", ["bold"])
        return True
    else:
        if not silent:
            TAc.NO()
            TAc.print(LANG.render_feedback("feasible-but-not-optimal-asteroid-set", "Your asteroids are indeed independent (no two of them are on a same row or column). However, there exists a bigger set of independent asteroids."), "red", ["bold"])
        if give_a_better_solution_if_any:
            bigger_set = max_independent_set(m,n,matrix)[:len(asteroids)+1]
            TAc.print(LANG.render_feedback("bigger-asteroid-set", f"A bigger set of independent asteroids could be: {bigger_set}"), "red", ["bold"])            
        return False

# TESTS
if __name__ == "__main__":
    # CONVERTERS FUNCTIONS:
    print('Test: subset_to_seq()')
    assert subset_to_seq([[0, 0, 1], [0, 1, 0]]) == ['r3', 'c2']
    assert subset_to_seq(NO_SOL) == NO_SOL
    print('==> OK\n')


    print('Test: seq_to_subset()')
    assert seq_to_subset(['r3', 'c2'], 4, 4) == [[0, 0, 1, 0], [0, 1, 0, 0]]
    assert seq_to_subset(['r1', 'c2', 'c2'], 3, 3) == [[1, 0, 0], [0, 0, 0]]
    assert seq_to_subset(NO_SOL, 4, 4) == NO_SOL
    print('==> OK\n')


    print('Test: parse_sol()')
    # import math_modeling as mu
    # raw_sol = mu.get_raw_solution()
    # print(f'raw_sol: {raw_sol}')
    assert parse_sol([NO_SOL], 'seq', 2, 2) == NO_SOL
    assert parse_sol([NO_SOL], 'subset', 2, 2) == NO_SOL
    assert parse_sol(['1 0 1 0 0 ', '0 1 0 0 1 '], 'subset', 5, 5) == \
        [[1, 0, 1, 0, 0], [0, 1, 0, 0, 1]]
    assert parse_sol([''], 'seq', 2, 2) == []
    assert parse_sol(['r1 r2 c2'], 'seq', 2, 2) == ['r1', 'r2', 'c2']
    print('==> OK\n')


    # TO_STRING and FROM_STRING FUNCTIONS:
    print('Test: seq_to_str()')
    assert seq_to_str(['r3', 'c2']) == 'r3 c2'
    assert seq_to_str(NO_SOL) == NO_SOL
    print('==> OK\n')


    print('Test: sol_to_str()')
    assert sol_to_str([[0, 0], [1, 1]], [[0, 1], [0, 0]]) == \
        "    0 0\n" + \
        "    ---\n" + \
        "0 | 0 0\n" + \
        "1 | 1 1"
    assert sol_to_str([[0, 0], [0, 1]], NO_SOL) == \
        "    ? ?\n" + \
        "    ---\n" + \
        "? | 0 0\n" + \
        "? | 0 1"
    print('==> OK\n')


    print('Test: subset_to_str()')
    assert subset_to_str([[0, 0, 1], [0, 1, 0]]) == "0 0 1\n0 1 0"
    assert subset_to_str(NO_SOL) == NO_SOL
    print('==> OK\n')


    print('Test: subset_to_str_list()')
    assert subset_to_str_list([[0, 0, 1], [0, 1, 0]]) == ['0 0 1', '0 1 0']
    assert subset_to_str_list(NO_SOL) == NO_SOL
    print('==> OK\n')


    print('Test: instance_to_str()')
    assert instance_to_str([[0, 0], [1, 1]]) == '0 0\n1 1'
    print('==> OK\n')


    print('Test: instance_to_txt()')
    print('MAYBE TODO?')
    print('==> OK\n')


    print('Test: instance_to_dat()')
    print('MAYBE TODO?')
    print('==> OK\n')


    print('Test: get_instance_from_str()')
    print('==> OK\n')


    print('Test: get_instance_from_txt()')
    assert get_instance_from_txt('0 0\n1 1', 'only_matrix') == [[0, 0], [1, 1]]
    print('==> OK\n')


    print('Test: get_instance_from_dat()')
    dat_instance = \
        "param M := 10;  # Number of rows\n" + \
        "param N := 2;  # Number of columns\n" + \
        "param MATRIX :  1 2 3 4 5 6 7 8 9 10:=\n" + \
        "                        \n" + \
        "              1    1 0 1 1 0 1 0 0 0 1   \n" + \
        "                                            \n" + \
        "\n" + \
        "              2    0 1 0 0 1 0 0 1 1 1 ;\n" + \
        "end;\n"
    assert get_instance_from_dat(dat_instance)  == [[1, 0, 1, 1, 0, 1, 0, 0, 0, 1], [0, 1, 0, 0, 1, 0, 0, 1, 1, 1]]
    dat_instance = \
        "param M := 2;  # Number of rows\n" + \
        "param N := 2;  # Number of columns\n" + \
        "param MATRIX :  1 2:=\n" + \
        "                        \n" + \
        "              1    1 0   \n" + \
        "                                            \n" + \
        "\n" + \
        "              2    0 1;\n" + \
        "end;\n"
    assert get_instance_from_dat(dat_instance)  == [[1, 0], [0, 1]]
    print('==> OK\n')


    # INSTANCE GENERATOR FUNCTIONS:
    print('Test: is_solvable_seed()')
    print('FOR DEFINITION')
    print('==> OK\n')


    print('Test: gen_instance_seed()')
    print('FOR DEFINITION')
    print('==> OK\n')


    print('Test: gen_instance()')
    print('MAYBE TODO?')
    print('==> OK\n')


    # CORE FUNCTIONS:
    print('Test: is_feasible_shooting()')
    print('Test: is_optimal_shooting()')

    print("FINISH")


