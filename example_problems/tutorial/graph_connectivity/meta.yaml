%YAML 1.2
---
public_folder: public
services:
# prendere spunto da model pirellone per la generazione dell'istanza
# prendere spunto da pirellone o da euler_dir per i servizio eval
  gimme_a_graph:
    description: 'This service provides you with a random graph with n nodes and m arcs. You have two main options when calling this service:\n    [input_mode=seed] to specify yourself the seed (when for example you want to reconsider the very same graph you have already met with this or other services).\n    [input_mode=random] to ask for a random seed (use this option when you want to specify whether the returned graph should be connected or not).\n   When given n, m, and also a seed value, the service returns the pseudo-random graph <n,m,seed> in the form of a stream. You may ask for this stream to get downloaded in a file on your local machine and/or displayed on the screen. Our format for streams storing graphs is the following: the first line contains the two integers n and m; then follow m lines, one for each arc. Each of these lines comprises two integers (the two endonodes of the arc). It is assumed that the labels of the nodes are the integers in [0,n).'
    evaluator: [python,services/gimme_graph_server.py]
    args:
      input_mode:
        regex: ^(random|seed)$
        default: random
        explain: 'choose whether you want to specify the seed (and hence the graph) or you need the service to randomly choose the seed and the graph within the space of our pseudo-random instances:' 
        explain1: '[random] the service generates a seed at random and then returns it as well as the pseudo-random instance <n,m,seed>.'
        explain2: '[seed] the service uses the seed you give it in order to generate and return the pseudo-random instance <n,m,seed>.'
      n:
        regex: ^([1-9][0-9]{0,3}|1000)$
        default: 6
        explain: Number of nodes of the graph.
      m:
        regex: ^(0|[1-9][0-9]{0,4}|10000)$
        default: 10
        explain: 'Number of edges of the graph.'
      seed:
        explain: 'The seed is any natural number in the interval [100000,999999]. This argument is used when you hold the instance descriptor of a specific instance and want to get that instance either downloaded in local as a file and/or displayed on your terminal screen. By a \''descriptor\'' we mean a triple <n,m,seed> that you hold from previous calls to this or other services for this problem.'
        regex: ^[1-9][0-9]{5,5}$
        default: 123456
      graph_connectivity:
        regex: ^(connected|disconnected|surprise_me)$
        default: surprise_me
      display:
        regex: ^(0|1)$
        default: 0
        explain: If this flag is set to 1 then the instance file is listed by the service.
      # download:
      #   regex: ^(0|1)$
      #   default: 0
      #   explain: 'If this flag is set to 1 then the instance file is downloaded in the \''download\'' sub-folder of the folder from which this TALight service call has been issued.'
      lang:
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it
  
  tell_if_graph_is_connected:
    description: This service recognizes the connectivity property for graphs. Besides telling whether the given graph is connected or not, the service can also be asked to provide a certificate of connectivity (or a certificate of non-connectivity).
    evaluator: [python, services/tell_if_graph_is_connected_server.py]
    args:
      with_yes_certificate:
        explain: when the input graph is connected, please, send me a certificate in the form of a spanning tree. This tree is encoded as a routing table towards its root (node 0 of the graph).
        regex: ^(0|1)$
        default: 0
      with_no_certificate:
        explain: when the input graph is NOT connected, please, send me a certificate in the form of a non-trivial partition of the nodes such that no arc has endpoints on different sides of the bipartition.
        regex: ^(0|1)$
        default: 0
      input_mode:
        regex: ^(terminal|TA_send_files_bot)$
        default: terminal
        explain: "choose the way to input your graph among:"
        explain1: "[terminal] you enter your instance (directed graph) directly by either typing it line after line or through cut and paste operations."
        explain2: "[TA_send_files_bot] send to the service a graph contained in a file on your local machine. To send the file you must use the TA_transfer_files_bot.py bot placed in the graph_connectivity/bots/ directory. Call the service with: rtal graph_connectivity tell_if_graph_is_connected -ainput_mode=TA_send_files_bot -- path_to_bot_dir/TA_send_files_bot.py path_to_instance_file_dir/your_graph.txt."
      lang:
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it
  check_certificate_of_connectivity:
    description: this service checks whether a routing table towards some root node is valid. If so it encodes a spanning tree and proves the connectivity of the graph
    evaluator: [python, services/check_certificate_of_connectivity_server.py]
    args:
      input_mode:
        regex: ^(terminal|TA_send_files_bot)$
        default: terminal
        explain: "choose the way to input your graph among:"
        explain1: "[terminal] you enter your instance (directed graph) directly by either typing it line after line or through cut and paste operations."
        explain2: "[TA_send_files_bot] with this, you can send to the service an instance (graph) encoded in a file sitting in your machine. To send the file you must to use the TA_send_files_bot.py bot placed in model_graph/bots/ directory. Call the service with: rtal connect strongly_connected_components check_is_sc -ainput_mode=TA_send_files_bot -- path_to_bot_dir/TA_send_files_bot.py path_to_instance_file_dir/your_graph.txt."
      n:
        regex: ^([1-9][0-9]{0,4}|1000)$
        explain: the number of nodes of the graph
      how_to_input_the_graph:
        regex: ^(lazy|([1-9]|[0-9]{5,5}))$
        explain: you can either enter the code (random seed) of one of our instances (n,seed) defining a graph you may have already encountered in other services for this problem or ask to enter your graph after the service has started up (lazy)
      silent:
        explain: if you specify the graph (through its generating seed) when launching rtal and nothing is wrong with your routing table for the graph then the service runs silently; otherwise it explains what is the problem in clear.
        regex: ^(0|1)$
        default: 0
      lang:
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it
  check_certificate_of_nonconnectivity:
    description: this service checks whether a bipartition of the nodes is a valid certificate of the non-connectivity of a given graph
    evaluator: [python, services/check_certificate_of_nonconnectivity_server.py]
    args:
      n:
        regex: ^([1-9][0-9]{0,4}|1000)$
        explain: the number of nodes of the graph
      how_to_input_the_graph:
        regex: ^(lazy|([1-9]|[0-9]{5,5}))$
        explain: you can either enter the code (random seed) of one of our instances (n,seed) defining a graph you may have already encountered in other services for this problem or ask to enter your graph after the service has started up (lazy)
      the_bipartition:
        regex: ^(lazy|(0  *|[1-9][0-9]{0,4}  *){1,999}versus  *(0  *|[1-9][0-9]{0,4}  *){0,998}(0|[1-9][0-9]{0,4}) *)$
      silent:
        explain: if nothing is wrong with your spanning tree for the graph you have specified us (through seed) then the service runs silently; otherwise it explains what is the problem in clear.
        regex: ^(0|1)$
        default: 0
      lang:
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it
  eval_bot_deciding_connectivity:
    evaluator: [python, services/eval_bot_deciding_connectivity_server.py]
    args:
      goal:
        explain: set your goal (efficient includes also correct).
        regex: ^(correct|quadratic|linear)$
        default: correct
      check_also_yes_certificate:
        explain: when the instance is a connected graph my bot will also produce a spanning tree of it, please, check also my certificate.
        regex: ^(0|1)$
        default: 0
      check_also_no_certificate:
        explain: when the instance is a non-connected graph my bot will also produce a bipartition, please, check also my certificate.
        regex: ^(0|1)$
        default: 0
      code_lang: 
        explain: the more we know about your bot the better we can estimate the efficiency of your algorithm.
        regex: ^(python|java|nodejs|compiled)$
        default: python
      lang:
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it
  synopsis:
    evaluator: [python, services/synopsis/synopsis_server.py]
    args:
      service:
        regex: ^((\S)+)$
        default: synopsis
        explain: any string without space characters but meant to specify one of the services of the problem {problem}
      lang:
        regex: ^(hardcoded|hardcoded_ext|en|it)$
        default: it
...
